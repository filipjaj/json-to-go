package jsontogo

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
)

// Result holds the output of the JSON to Go conversion
type Result struct {
	Go    string
	Error string
}

// Options for JSON to Go conversion
type Options struct {
	TypeName     string
	Flatten      bool
	Example      bool
	AllOmitempty bool
}

// JSONToGo converts JSON to a Go type definition
func JSONToGo(jsonInput string, typename string, flatten, example, allOmitempty bool) Result {
	opts := Options{
		TypeName:     typename,
		Flatten:      flatten,
		Example:      example,
		AllOmitempty: allOmitempty,
	}
	return jsonToGoWithOptions(jsonInput, opts)
}

func jsonToGoWithOptions(jsonInput string, opts Options) Result {
	converter := &converter{
		opts:                   opts,
		seen:                   make(map[string][]string),
		stack:                  []string{},
		globallySeenTypeNames:  []string{},
	}
	
	// Hack that forces floats to stay as floats
	re := regexp.MustCompile(`(:\s*\[?\s*-?\d*)\.0`)
	jsonInput = re.ReplaceAllString(jsonInput, "${1}.1")
	
	var data interface{}
	err := json.Unmarshal([]byte(jsonInput), &data)
	if err != nil {
		return Result{Go: "", Error: err.Error()}
	}
	
	converter.scope = data
	
	typename := format(opts.TypeName)
	if typename == "" {
		typename = "AutoGenerated"
	}
	
	converter.append(fmt.Sprintf("type %s ", typename))
	converter.parseScope(converter.scope, 0)
	
	if opts.Flatten {
		converter.go_ += converter.accumulator
	}
	
	// Add final newline for POSIX 3.206
	if !strings.HasSuffix(converter.go_, "\n") {
		converter.go_ += "\n"
	}
	
	return Result{Go: converter.go_}
}

type converter struct {
	opts                   Options
	scope                  interface{}
	go_                    string
	tabs                   int
	seen                   map[string][]string
	stack                  []string
	accumulator            string
	innerTabs              int
	parent                 string
	globallySeenTypeNames  []string
	previousParents        string
}

func (c *converter) parseScope(scope interface{}, depth int) {
	if scope == nil {
		if c.opts.Flatten && depth >= 2 {
			c.appender(goType(scope))
		} else {
			c.append(goType(scope))
		}
		return
	}
	
	switch v := scope.(type) {
	case []interface{}:
		c.parseSlice(v, depth)
	case map[string]interface{}:
		if c.opts.Flatten {
			if depth >= 2 {
				c.appender(c.parent)
			} else {
				c.append(c.parent)
			}
		}
		c.parseStruct(depth+1, c.innerTabs, v, nil, c.previousParents)
	default:
		if c.opts.Flatten && depth >= 2 {
			c.appender(goType(scope))
		} else {
			c.append(goType(scope))
		}
	}
}

func (c *converter) parseSlice(scope []interface{}, depth int) {
	var sliceType string
	scopeLength := len(scope)
	
	for i := 0; i < scopeLength; i++ {
		thisType := goType(scope[i])
		if sliceType == "" {
			sliceType = thisType
		} else if sliceType != thisType {
			sliceType = mostSpecificPossibleGoType(thisType, sliceType)
			if sliceType == "any" {
				break
			}
		}
	}
	
	var slice string
	if c.opts.Flatten && (sliceType == "struct" || sliceType == "slice") {
		slice = "[]" + c.parent
	} else {
		slice = "[]"
	}
	
	if c.opts.Flatten && depth >= 2 {
		c.appender(slice)
	} else {
		c.append(slice)
	}
	
	if sliceType == "struct" {
		allFields := make(map[string]*fieldInfo)
		
		// For each field count how many times it appears
		for i := 0; i < scopeLength; i++ {
			if obj, ok := scope[i].(map[string]interface{}); ok {
				for keyname, value := range obj {
					if _, exists := allFields[keyname]; !exists {
						allFields[keyname] = &fieldInfo{
							value: value,
							count: 0,
						}
					} else {
						existingValue := allFields[keyname].value
						currentValue := value
						
						if !areSameType(existingValue, currentValue) {
							if existingValue != nil {
								allFields[keyname].value = nil // force type "any" if types are not identical
							}
							allFields[keyname].count++
							continue
						}
						
						// If variable was first detected as int and later as float64, use float64
						if areSameType(currentValue, float64(1)) {
							allFields[keyname].value = findBestValueForNumberType(existingValue, currentValue)
						}
						
						if areObjects(existingValue, currentValue) {
							existingKeys := getKeys(existingValue)
							currentKeys := getKeys(currentValue)
							if !compareObjectKeys(currentKeys, existingKeys) {
								keyname = keyname + "_" + uuidv4()
								allFields[keyname] = &fieldInfo{
									value: currentValue,
									count: 0,
								}
							}
						}
					}
					allFields[keyname].count++
				}
			}
		}
		
		// Create a common struct with all fields found
		structMap := make(map[string]interface{})
		omitempty := make(map[string]bool)
		for keyname, elem := range allFields {
			structMap[keyname] = elem.value
			omitempty[keyname] = elem.count != scopeLength
		}
		c.parseStruct(depth+1, c.innerTabs, structMap, omitempty, c.previousParents)
	} else if sliceType == "slice" {
		if len(scope) > 0 {
			c.parseScope(scope[0], depth)
		}
	} else {
		if c.opts.Flatten && depth >= 2 {
			if sliceType == "" {
				c.appender("any")
			} else {
				c.appender(sliceType)
			}
		} else {
			if sliceType == "" {
				c.append("any")
			} else {
				c.append(sliceType)
			}
		}
	}
}

type fieldInfo struct {
	value interface{}
	count int
}

func (c *converter) parseStruct(depth, innerTabs int, scope map[string]interface{}, omitempty map[string]bool, oldParents string) {
	if c.opts.Flatten {
		if depth >= 2 {
			c.stack = append(c.stack, "\n")
		} else {
			c.stack = append(c.stack, "")
		}
	}
	
	seenTypeNames := []string{}
	
	if c.opts.Flatten && depth >= 2 {
		parentType := fmt.Sprintf("type %s", c.parent)
		scopeKeys := formatScopeKeys(getMapKeys(scope))
		
		if existingKeys, exists := c.seen[c.parent]; exists && compareObjectKeys(scopeKeys, existingKeys) {
			c.stack = c.stack[:len(c.stack)-1] // pop
			return
		}
		c.seen[c.parent] = scopeKeys
		
		c.appender(fmt.Sprintf("%s struct {\n", parentType))
		innerTabs++
		previousParents := c.parent
		
		for _, keyname := range getSortedKeys(scope) {
			originalName := getOriginalName(keyname)
			c.indenter(innerTabs)
			
			var typename string
			if isObjectOrArray(scope[keyname]) {
				typename = uniqueTypeName(format(originalName), c.globallySeenTypeNames, previousParents)
				c.globallySeenTypeNames = append(c.globallySeenTypeNames, typename)
			} else {
				typename = uniqueTypeName(format(originalName), seenTypeNames, "")
				seenTypeNames = append(seenTypeNames, typename)
			}
			
			c.appender(typename + " ")
			c.parent = typename
			c.parseScope(scope[keyname], depth)
			c.appender(fmt.Sprintf(" `json:\"%s", originalName))
			if c.opts.AllOmitempty || (omitempty != nil && omitempty[keyname]) {
				c.appender(",omitempty")
			}
			c.appender("\"`\n")
		}
		c.indenter(innerTabs - 1)
		c.appender("}")
		c.previousParents = oldParents
		innerTabs--
	} else {
		c.append("struct {\n")
		c.tabs++
		previousParents := c.parent
		
		for _, keyname := range getSortedKeys(scope) {
			originalName := getOriginalName(keyname)
			c.indent(c.tabs)
			
			var typename string
			if isObjectOrArray(scope[keyname]) {
				typename = uniqueTypeName(format(originalName), c.globallySeenTypeNames, previousParents)
				c.globallySeenTypeNames = append(c.globallySeenTypeNames, typename)
			} else {
				typename = uniqueTypeName(format(originalName), seenTypeNames, "")
				seenTypeNames = append(seenTypeNames, typename)
			}
			
			c.append(typename + " ")
			c.parent = typename
			c.parseScope(scope[keyname], depth)
			c.append(fmt.Sprintf(" `json:\"%s", originalName))
			if c.opts.AllOmitempty || (omitempty != nil && omitempty[keyname]) {
				c.append(",omitempty")
			}
			if c.opts.Example && scope[keyname] != "" && !isObjectOrArray(scope[keyname]) {
				c.append(fmt.Sprintf("\" example:\"%v", scope[keyname]))
			}
			c.append("\"`\n")
		}
		c.indent(c.tabs - 1)
		c.append("}")
		c.previousParents = oldParents
		c.tabs--
	}
	
	if c.opts.Flatten {
		popped := c.stack[len(c.stack)-1]
		c.stack = c.stack[:len(c.stack)-1]
		c.accumulator += popped
	}
}

func (c *converter) indent(tabs int) {
	for i := 0; i < tabs; i++ {
		c.go_ += "\t"
	}
}

func (c *converter) append(str string) {
	c.go_ += str
}

func (c *converter) indenter(tabs int) {
	if len(c.stack) > 0 {
		for i := 0; i < tabs; i++ {
			c.stack[len(c.stack)-1] += "\t"
		}
	}
}

func (c *converter) appender(str string) {
	if len(c.stack) > 0 {
		c.stack[len(c.stack)-1] += str
	}
}

// Helper functions

func uniqueTypeName(name string, seen []string, prefix string) string {
	if !contains(seen, name) {
		return name
	}
	
	// Check if we can get a unique name by prefixing it
	if prefix != "" {
		prefixedName := prefix + name
		if !contains(seen, prefixedName) {
			return prefixedName
		}
	}
	
	i := 0
	for {
		newName := name + strconv.Itoa(i)
		if !contains(seen, newName) {
			return newName
		}
		i++
	}
}

func format(str string) string {
	str = formatNumber(str)
	
	sanitized := toProperCase(str)
	re := regexp.MustCompile(`[^a-zA-Z0-9]`)
	sanitized = re.ReplaceAllString(sanitized, "")
	
	if sanitized == "" {
		return "NAMING_FAILED"
	}
	
	// After sanitizing, characters can start with a number
	return formatNumber(sanitized)
}

func formatNumber(str string) string {
	if str == "" {
		return ""
	}
	
	// All digits
	if matched, _ := regexp.MatchString(`^\d+$`, str); matched {
		return "Num" + str
	}
	
	// Starts with digit
	if matched, _ := regexp.MatchString(`^\d`, str); matched {
		numbers := map[rune]string{
			'0': "Zero_",
			'1': "One_",
			'2': "Two_",
			'3': "Three_",
			'4': "Four_",
			'5': "Five_",
			'6': "Six_",
			'7': "Seven_",
			'8': "Eight_",
			'9': "Nine_",
		}
		firstChar := rune(str[0])
		if prefix, ok := numbers[firstChar]; ok {
			return prefix + str[1:]
		}
	}
	
	return str
}

func goType(val interface{}) string {
	if val == nil {
		return "any"
	}
	
	switch v := val.(type) {
	case string:
		// Check for ISO 8601 timestamp
		matched, _ := regexp.MatchString(`^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$`, v)
		if matched {
			return "time.Time"
		}
		return "string"
	case float64:
		if v == math.Floor(v) {
			if v > -2147483648 && v < 2147483647 {
				return "int"
			}
			return "int64"
		}
		return "float64"
	case bool:
		return "bool"
	case []interface{}:
		return "slice"
	case map[string]interface{}:
		return "struct"
	default:
		return "any"
	}
}

func findBestValueForNumberType(existingValue, newValue interface{}) interface{} {
	if !areSameType(newValue, float64(1)) {
		return nil
	}
	
	newGoType := goType(newValue)
	existingGoType := goType(existingValue)
	
	if newGoType == existingGoType {
		return existingValue
	}
	
	// Always upgrade to float64
	if newGoType == "float64" {
		return newValue
	}
	if existingGoType == "float64" {
		return existingValue
	}
	
	// Force upgrade to float64 for mixed int/float types
	if strings.Contains(newGoType, "float") && strings.Contains(existingGoType, "int") {
		return math.MaxFloat64
	}
	if strings.Contains(newGoType, "int") && strings.Contains(existingGoType, "float") {
		return math.MaxFloat64
	}
	
	// Both are ints
	if strings.Contains(newGoType, "int") && strings.Contains(existingGoType, "int") {
		newFloat, _ := toFloat64(newValue)
		existingFloat, _ := toFloat64(existingValue)
		existingValueAbs := math.Abs(existingFloat)
		newValueAbs := math.Abs(newFloat)
		
		if !math.IsInf(existingValueAbs+newValueAbs, 0) {
			return existingValueAbs + newValueAbs
		}
		return float64(math.MaxInt64)
	}
	
	return nil
}

func mostSpecificPossibleGoType(typ1, typ2 string) string {
	if strings.HasPrefix(typ1, "float") && strings.HasPrefix(typ2, "int") {
		return typ1
	}
	if strings.HasPrefix(typ1, "int") && strings.HasPrefix(typ2, "float") {
		return typ2
	}
	return "any"
}

func toProperCase(str string) string {
	// Convert SCREAMING_SNAKE_CASE to snake_case
	if matched, _ := regexp.MatchString(`^[_A-Z0-9]+$`, str); matched {
		str = strings.ToLower(str)
	}
	
	// Common Go initialisms
	commonInitialisms := []string{
		"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML",
		"HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS",
		"RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP",
		"UI", "UID", "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP",
		"XSRF", "XSS",
	}
	
	// Split by underscore and process each part
	parts := strings.Split(str, "_")
	result := make([]string, 0, len(parts))
	
	for _, part := range parts {
		if part == "" {
			continue
		}
		
		// Check if it's a common initialism
		upperPart := strings.ToUpper(part)
		isInitialism := false
		for _, initialism := range commonInitialisms {
			if upperPart == initialism {
				result = append(result, initialism)
				isInitialism = true
				break
			}
		}
		
		if !isInitialism {
			// Capitalize first letter and lowercase the rest
			if len(part) > 0 {
				result = append(result, strings.ToUpper(part[0:1])+strings.ToLower(part[1:]))
			}
		}
	}
	
	// Join all parts
	combined := strings.Join(result, "")
	
	// Handle camelCase or PascalCase input that wasn't split by underscores
	if !strings.Contains(str, "_") {
		// Process existing camelCase
		re := regexp.MustCompile(`([a-z])([A-Z])`)
		combined = re.ReplaceAllString(str, "$1$2")
		
		// Check for initialisms at word boundaries
		for _, initialism := range commonInitialisms {
			// Replace word boundary versions
			lowerInitialism := strings.ToLower(initialism)
			re := regexp.MustCompile(`(?i)\b` + lowerInitialism + `\b`)
			combined = re.ReplaceAllStringFunc(combined, func(match string) string {
				return initialism
			})
		}
		
		// Ensure first letter is capitalized
		if len(combined) > 0 {
			combined = strings.ToUpper(combined[0:1]) + combined[1:]
		}
	}
	
	return combined
}

func uuidv4() string {
	b := make([]byte, 16)
	rand.Read(b)
	b[6] = (b[6] & 0x0f) | 0x40 // Version 4
	b[8] = (b[8] & 0x3f) | 0x80 // Variant 10
	return fmt.Sprintf("%x-%x-%x-%x-%x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}

func getOriginalName(unique string) string {
	reLiteralUUID := regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	uuidLength := 36
	
	if len(unique) >= uuidLength {
		tail := unique[len(unique)-uuidLength:]
		if reLiteralUUID.MatchString(tail) {
			return unique[:len(unique)-(uuidLength+1)]
		}
	}
	return unique
}

func areObjects(objectA, objectB interface{}) bool {
	_, okA := objectA.(map[string]interface{})
	_, okB := objectB.(map[string]interface{})
	return okA && okB
}

func areSameType(objectA, objectB interface{}) bool {
	return fmt.Sprintf("%T", objectA) == fmt.Sprintf("%T", objectB)
}

func compareObjectKeys(itemAKeys, itemBKeys []string) bool {
	lengthA := len(itemAKeys)
	lengthB := len(itemBKeys)
	
	if lengthA == 0 && lengthB == 0 {
		return true
	}
	
	if lengthA != lengthB {
		return false
	}
	
	for _, item := range itemAKeys {
		if !contains(itemBKeys, item) {
			return false
		}
	}
	return true
}

func formatScopeKeys(keys []string) []string {
	result := make([]string, len(keys))
	for i, key := range keys {
		result[i] = format(key)
	}
	return result
}

func getKeys(obj interface{}) []string {
	if m, ok := obj.(map[string]interface{}); ok {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		return keys
	}
	return []string{}
}

func getMapKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

func getSortedKeys(m map[string]interface{}) []string {
	keys := getMapKeys(m)
	// Keep original order (Go maps are ordered in Go 1.12+)
	return keys
}

func isObjectOrArray(val interface{}) bool {
	if val == nil {
		return false
	}
	_, isMap := val.(map[string]interface{})
	_, isSlice := val.([]interface{})
	return isMap || isSlice
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func toFloat64(val interface{}) (float64, bool) {
	switch v := val.(type) {
	case float64:
		return v, true
	case int:
		return float64(v), true
	case int64:
		return float64(v), true
	default:
		return 0, false
	}
}