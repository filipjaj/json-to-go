package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	jsontogo "github.com/filipjaj/json-to-go"
)

func main() {
	// Define flags
	typename := flag.String("type", "AutoGenerated", "Name for the generated type")
	flatten := flag.Bool("flatten", true, "Flatten nested types to top-level declarations")
	example := flag.Bool("example", false, "Include example tags")
	omitempty := flag.Bool("omitempty", false, "Add omitempty to all fields")
	output := flag.String("output", "", "Output file path (default: stdout)")
	url := flag.String("url", "", "Fetch JSON from URL")
	help := flag.Bool("help", false, "Show help message")
	
	flag.Parse()
	
	if *help {
		showHelp()
		return
	}
	
	// Check if user put flags after positional arguments
	args := flag.Args()
	for _, arg := range args {
		if strings.HasPrefix(arg, "-") {
			fmt.Fprintf(os.Stderr, "Error: Flags must come BEFORE positional arguments\n")
			fmt.Fprintf(os.Stderr, "You wrote: json-to-go ... %s %s\n", args[0], arg)
			fmt.Fprintf(os.Stderr, "Correct:   json-to-go %s ... %s\n\n", arg, args[0])
			fmt.Fprintf(os.Stderr, "Run 'json-to-go -help' for usage information\n")
			os.Exit(1)
		}
	}
	
	var jsonInput string
	var err error
	
	// Priority: URL flag > positional argument > stdin
	if *url != "" {
		jsonInput, err = fetchFromURL(*url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error fetching URL: %v\n", err)
			os.Exit(1)
		}
	} else {
		// Check if argument is provided
		if len(args) > 0 {
			input := args[0]
			
			// Check if it's a URL
			if isURL(input) {
				jsonInput, err = fetchFromURL(input)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error fetching URL: %v\n", err)
					os.Exit(1)
				}
			} else {
				// It's a file
				data, err := os.ReadFile(input)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
					os.Exit(1)
				}
				jsonInput = string(data)
			}
		} else {
			// Read from stdin
			jsonInput, err = readStdin()
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
				os.Exit(1)
			}
		}
	}
	
	// Convert JSON to Go
	result := jsontogo.JSONToGo(jsonInput, *typename, *flatten, *example, *omitempty)
	
	if result.Error != "" {
		fmt.Fprintf(os.Stderr, "Error: %s\n", result.Error)
		os.Exit(1)
	}
	
	// Write output
	if *output != "" {
		err := os.WriteFile(*output, []byte(result.Go), 0644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
			os.Exit(1)
		}
		fmt.Fprintf(os.Stderr, "Successfully wrote Go structs to %s\n", *output)
	} else {
		fmt.Print(result.Go)
	}
}

func isURL(str string) bool {
	return strings.HasPrefix(str, "http://") || strings.HasPrefix(str, "https://")
}

func fetchFromURL(url string) (string, error) {
	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	
	resp, err := client.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to fetch URL: %w", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("HTTP error: %s", resp.Status)
	}
	
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %w", err)
	}
	
	return string(body), nil
}

func readStdin() (string, error) {
	reader := bufio.NewReader(os.Stdin)
	var builder strings.Builder
	
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				builder.WriteString(line)
				break
			}
			return "", err
		}
		builder.WriteString(line)
	}
	
	return builder.String(), nil
}

func showHelp() {
	fmt.Println("JSON-to-Go Converter")
	fmt.Println("\nConvert JSON to Go struct definitions")
	fmt.Println("\nUsage:")
	fmt.Println("  json-to-go [options] [file|url]")
	fmt.Println("\n⚠️  IMPORTANT: All flags must come BEFORE the file/url argument")
	fmt.Println("\nOptions:")
	flag.PrintDefaults()
	fmt.Println("\nExamples:")
	fmt.Println("  # From stdin:")
	fmt.Println(`  echo '{"name":"John","age":30}' | json-to-go`)
	fmt.Println("\n  # From file:")
	fmt.Println("  json-to-go data.json")
	fmt.Println("\n  # From URL:")
	fmt.Println("  json-to-go -type=User https://api.example.com/users/1")
	fmt.Println("  json-to-go -url=https://api.example.com/data -type=Response")
	fmt.Println("\n  # With custom type name:")
	fmt.Println(`  echo '{"name":"John"}' | json-to-go -type=Person`)
	fmt.Println("\n  # Write to file (FLAGS FIRST!):")
	fmt.Println("  json-to-go -type=User -output=types.go https://api.example.com/users/1")
	fmt.Println("  json-to-go -type=User -output=types.go data.json")
	fmt.Println("\n  # With omitempty on all fields:")
	fmt.Println(`  echo '{"name":"John"}' | json-to-go -omitempty`)
}
